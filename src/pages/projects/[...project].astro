---
import ProjectLayout from '../../layouts/ProjectLayout.astro';
import { getCollection } from 'astro:content';

export async function getStaticPaths() {
  const entries = await getCollection('projects');

  return entries.map(entry => {
    const slug = entry.slug;
    const isIndex = entry.id.endsWith('/index.md') || entry.id === 'index.md';
    
    
    const segments = slug.split('/');
    //this is used to get only direct children
    const depth = segments.length;
    const childItems = isIndex
      ? entries.filter(e => e.slug.startsWith(slug + '/') && e.slug !== slug && e.slug.split('/').length === depth + 1)
      : [];

    const fatherSlug = segments.slice(0, -1).join('/');


    // Build breadcrumb for this entry
    const breadcrumb = segments.map((_, idx, arr) => {
      const partial = arr.slice(0, idx + 1).join('/');
      const segEntry = entries.find(e => e.slug === partial);
      const label = (segEntry as any)?.data?.title || arr[idx];
      return { partial, label, url: `/projects/${partial}/`, current: idx === arr.length - 1 };
    });
    let parentPage;
    if (breadcrumb.length > 1) {
      parentPage = {
      title: breadcrumb[breadcrumb.length - 2].label,
      url: breadcrumb[breadcrumb.length - 2].url,
      };
    } else {
      parentPage = { title: 'Projects', url: '/projects/' };
    }
    

    // Compute siblings and sort by filename (last segment) for deterministic navigation
    let prev: { slug: string; title: string } | null = null;
    let next: { slug: string; title: string } | null = null;
    
    //FINDING sisters (same depth, same parent)
    const sisters = entries.filter(e => {
      const eSegments = e.slug.split('/');
      if (eSegments.length !== depth) return false;
      // For top-level (no fatherSlug), any item with same depth is a sister; else require strict parent match
      return fatherSlug === '' ? true : e.slug.startsWith(fatherSlug + '/');
    });

    //SORTING sisters by filename (last segment)
    const collator = new Intl.Collator('en', { numeric: true, sensitivity: 'base' });
    const lastSeg = (s: string) => s.split('/').pop() || s;
    sisters.sort((a, b) => collator.compare(lastSeg(a.slug), lastSeg(b.slug)));

    const idx = sisters.findIndex(e => e.slug === slug);
    if (idx !== -1) {
      const prevSister = idx > 0 ? sisters[idx - 1] : null;
      const nextSister = idx < sisters.length - 1 ? sisters[idx + 1] : null;
      prev = prevSister ? { slug: prevSister.slug, title: (prevSister as any).data?.title } : null;
      next = nextSister ? { slug: nextSister.slug, title: (nextSister as any).data?.title } : null;
    }
    
    return {
      params: { project: slug },
      props: { slug, mainEntry: entry, childItems, isIndex, breadcrumb, prev, next, parentPage: parentPage, order: 'file' }
    };
  });
}
const { slug, mainEntry, childItems, isIndex, breadcrumb, prev, next, parentPage, order } = Astro.props as any;
---

<ProjectLayout
  collection="projects"
  slug={slug}
  mainEntry={mainEntry}
  childItems={childItems}
  isIndex={isIndex}
  breadcrumb={breadcrumb}
  prev={prev}
  next={next}
  parentPage={parentPage}
  order={order}
/>
