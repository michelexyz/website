---
import BaseLayout from './BaseLayout.astro';
import ProjectPost from '../components/ProjectPost.astro';
import Sections from '../components/feed/Sections.astro';
import Tags from '../components/Tags.astro';
import { getCollection, render } from 'astro:content';
import PrevNext from '../components/navigation/PrevNext.astro';

interface Props {
  collection: string;
  slug: string;
  order?: 'pubDate' | 'title' | 'file';
  mainEntry?: any;
  childItems?: any[];
  isIndex?: boolean;
  breadcrumb?: { partial: string; label: string; url: string; current: boolean }[];
  prev?: { slug: string; title?: string } | null;
  next?: { slug: string; title?: string } | null;
  parentPage?: { title: string; url: string } | null;
}

const { collection, slug, order = 'pubDate', mainEntry: passedMain, childItems: passedChildren, isIndex = true, breadcrumb: passedBreadcrumb, prev, next, parentPage: parentPage } = Astro.props as Props;

// Load collection entries only if we need to compute breadcrumb or find mainEntry/children not passed
const needEntries = !passedMain || !passedChildren || !passedBreadcrumb;
const entries = needEntries ? await getCollection(collection as any) as any[] : [];

const mainEntry = passedMain ?? entries.find(e => e.slug === slug);
let childItems = passedChildren ?? entries.filter(e => e.slug.startsWith(`${slug}/`));

const collator = new Intl.Collator('en', { numeric: true, sensitivity: 'base' });
const lastSeg = (s: string) => s.split('/').pop() || s;

if (order === 'pubDate') {
  childItems.sort((a, b) => {
    const ad = (a.data as any).pubDate?.getTime?.() || 0;
    const bd = (b.data as any).pubDate?.getTime?.() || 0;
    return ad - bd;
  });
} else if (order === 'title') {
  childItems.sort((a, b) => {
    const at = ((a.data as any).title || '').localeCompare((b.data as any).title || '');
    return at;
  });
} else if (order === 'file') {
  childItems.sort((a, b) => collator.compare(lastSeg(a.slug), lastSeg(b.slug)));
}

let Content: any = null;
let title = slug;
if (mainEntry) {
  const rendered = await render(mainEntry as any);
  Content = rendered.Content;
  title = (mainEntry as any).data?.title || slug;
}

// Use passed breadcrumb if present, else compute (fallback for other collections)
const breadcrumb = passedBreadcrumb ?? (() => {
  const segs = slug.split('/');
  return segs.map((_, idx, arr) => {
    const partial = arr.slice(0, idx + 1).join('/');
    const entry = entries.find((e: any) => e.slug === partial);
    const label = entry?.data?.title || arr[idx];
    return { partial, label, url: `/${collection}/${partial}/`, current: idx === arr.length - 1 };
  });
})();
---
<style>
  .lead { margin: 0.5rem 0 1rem; color: #475569; }
  .sub-items { list-style: none; padding: 0; margin: 0; }
  .no-items { color: #64748b; font-style: italic; }
  h2 { margin-top: 1.25rem; }
  .lead :global(p:first-child) { margin-top: 0; }
  .lead :global(p:last-child) { margin-bottom: 0; }
  .breadcrumb { font-size: 0.75rem; margin-bottom: 0.75rem; display: flex; flex-wrap: wrap; gap: 0.25rem; align-items: center; }
  .breadcrumb a { text-decoration: none; color: var(--accent); }
  .breadcrumb a:hover { text-decoration: underline; }
  .breadcrumb .sep { opacity: 0.6; color: var(--text-muted); }
</style>

<BaseLayout pageTitle={title}>
  {breadcrumb.length > 1 && (
    <nav class="breadcrumb" aria-label="Breadcrumb">
      {breadcrumb.map((b, i) => (
        <>
          {!b.current ? <a href={b.url}>{b.label}</a> : <span aria-current="page">{b.label}</span>}
          {i < breadcrumb.length - 1 && <span class="sep">/</span>}
        </>
      ))}
    </nav>
  )}
  {mainEntry && <Tags tags={(mainEntry as any).data?.tags} />}
  {Content && (
    <section class="lead">
      <Content />
    </section>
  )}

  <slot />

  {isIndex && (
    <>
      <h2>Sections</h2>
      <Sections
        items={childItems.map((item: any) => ({
          url: `/${collection}/${item.slug}/`,
          title: item.data?.title,
          pubDate: item.data?.pubDate,
          description: item.data?.description
        }))}
        emptyText="No sections yet."
      />
    </>
  )}
  
  <PrevNext prev={prev} next={next} parentPage={parentPage} base={`/${collection}`} />
  
</BaseLayout>
